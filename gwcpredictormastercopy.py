# -*- coding: utf-8 -*-
"""GWCPredictorMasterCopy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XFF268nHrLVjt_TiNoRyTAHsKg2KdyeK

Importing the Dependencies
"""

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import LabelEncoder
from sklearn.impute import SimpleImputer

"""Data Collection and Processing"""

#loading the csv data to a Pandas DataFrame
heartdata = pd.read_csv('/content/heart_disease_uci.csv')

#print first 5 rows of the dataset
heartdata.head()

#print last 5 rows of the dataset
heartdata.tail()

##number of rows and columns in the dataset
heartdata.shape

#getting some info about the data
heartdata.info()

#checking for missing values
heartdata.isnull().sum()

#statistical measures about the data
heartdata.describe()

#checking distribution of num variable
#target [0=no heart disease; 1,2,3,4 = stages of heart disease]
heartdata['heart_disease_binary'] = heartdata['num'].apply(lambda x: 1 if x > 0 else 0)
#heartdata['num'].value_counts()
heartdata['heart_disease_binary'].value_counts()

x = heartdata.drop(columns=['num', 'heart_disease_binary'], axis=1)
y = heartdata['heart_disease_binary']
print(y)

"""Splitting the Data into Training and Test Data"""

#test_size is the percentage of data being used as test data
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, stratify=y, random_state=2)

print(x.shape, x_train.shape, x_test.shape)

"""Model Training

Logistic Regression
"""

encoder = LabelEncoder()
# Iterate through columns and transform object type columns
for col in x_train.columns:
    if x_train[col].dtype == 'object':
        # Replace NaN values with a placeholder, for example 'unknown'
        x_train[col] = x_train[col].fillna('unknown')
        x_test[col] = x_test[col].fillna('unknown')

        # Combine unique values from both train and test sets before fitting
        all_values = pd.concat([x_train[col], x_test[col]]).unique()

        # Convert boolean values to strings before fitting LabelEncoder
        all_values = [str(value) for value in all_values]  # This line is the fix

        encoder.fit(all_values)

        # Transform the column in BOTH training and testing data using the encoder
        x_train[col] = encoder.transform(x_train[col].astype(str)) # Also cast to string here
        x_test[col] = encoder.transform(x_test[col].astype(str)) # Also cast to string here

# Impute missing numerical values using SimpleImputer
imputer = SimpleImputer(strategy='mean')  # or 'median', 'most_frequent'

# Apply the imputer to numerical features in both training and testing data
x_train = imputer.fit_transform(x_train) # Fit and transform on training data
x_test = imputer.transform(x_test) # Only transform on testing data

#training the Logistic Regression model with Training data
model = LogisticRegression()
model.fit(x_train, y_train)

"""Model Evaluation

Accuracy Score
"""

#accuracy on training data
x_train_prediction = model.predict(x_train)
training_data_accuracy = accuracy_score(x_train_prediction, y_train)

print("Accuracy on Training data:", training_data_accuracy)

#accuracy on test data
x_test_prediction = model.predict(x_test)
test_data_accuracy = accuracy_score(x_test_prediction, y_test)

print("Accuracy on Test data:", test_data_accuracy)

